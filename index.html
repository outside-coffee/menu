<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Outside Menu</title>

  <style>
    :root{
      --bg:#f5f5f5;
      --card:#ffffff;
      --shadow: 0 18px 45px rgba(0,0,0,.14);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#111;
      overflow: hidden; /* on scrolle dans le container */
    }

    /* Container plein écran, scroll vertical avec snap */
    .slides{
      height: 100dvh;          /* meilleur sur mobile moderne */
      height: 100vh;           /* fallback */
      overflow-y: auto;
      scroll-snap-type: y mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding: max(env(safe-area-inset-top), 16px) 16px max(env(safe-area-inset-bottom), 16px);
      display:flex;
      flex-direction: column;
      gap: 14px;
    }

    /* Chaque slide = plein écran, centré */
    .slide{
      scroll-snap-align: start;
      height: calc(100dvh - max(env(safe-area-inset-top), 16px) - max(env(safe-area-inset-bottom), 16px));
      height: calc(100vh - max(env(safe-area-inset-top), 16px) - max(env(safe-area-inset-bottom), 16px));
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Carte image */
    .frame{
      width: min(520px, 100%);
      height: 100%;
      max-height: 920px;
      border-radius: var(--radius);
      background: var(--card);
      box-shadow: var(--shadow);
      overflow: hidden;

      /* animation entrée légère */
      opacity: 0;
      transform: translateY(28px);
      transition: opacity .6s ease, transform .6s ease;
    }
    .frame.visible{
      opacity: 1;
      transform: translateY(0);
    }

    /* Image: on voit tout (sans crop) */
    .frame img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      display:block;
      background: var(--card);
    }

    /* Petit compteur discret */
    .hint{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: max(env(safe-area-inset-bottom), 10px);
      background: rgba(0,0,0,.55);
      color: #fff;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      user-select: none;
      pointer-events: none;
    }
  </style>
  <link rel="icon" type="image/png" href="logo.png">
<link rel="apple-touch-icon" href="logo.png">

</head>

<body>

  <div class="slides" id="slides">
    <section class="slide" data-index="1"><div class="frame"><img src="1.png" alt="Outside cover"></div></section>
    <section class="slide" data-index="2"><div class="frame"><img src="2.png" alt="Coffee menu"></div></section>
    <section class="slide" data-index="3"><div class="frame"><img src="3.png" alt="Combo menu"></div></section>
    <section class="slide" data-index="4"><div class="frame"><img src="4.png" alt="Fresh & Chill"></div></section>
    <section class="slide" data-index="5"><div class="frame"><img src="5.png" alt="Cookieside"></div></section>
  </div>

  <div class="hint" id="hint">1 / 5</div>

  <script>
    const slidesEl = document.getElementById('slides');
    const hintEl = document.getElementById('hint');
    const frames = document.querySelectorAll('.frame');
    const slides = Array.from(document.querySelectorAll('.slide'));

    // Fade/slide au scroll (léger)
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) e.target.classList.add('visible');
      });
    }, { threshold: 0.25 });

    frames.forEach(f => io.observe(f));

    // Indicateur 1/5
    const ioIndex = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          const idx = e.target.getAttribute('data-index');
          hintEl.textContent = `${idx} / ${slides.length}`;
        }
      });
    }, { threshold: 0.6 });

    slides.forEach(s => ioIndex.observe(s));

    // Swipe (tactile) : on détecte le flick vertical et on snap vers slide suivante/précédente
    let startY = 0, startX = 0, tracking = false, startTime = 0;

    slidesEl.addEventListener('touchstart', (e) => {
      if (!e.touches || e.touches.length !== 1) return;
      tracking = true;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      startTime = Date.now();
    }, { passive: true });

    slidesEl.addEventListener('touchend', (e) => {
      if (!tracking) return;
      tracking = false;

      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;

      const dx = t.clientX - startX;
      const dy = t.clientY - startY;
      const dt = Date.now() - startTime;

      // On ignore si c'est surtout horizontal (pour éviter conflit avec gesture)
      if (Math.abs(dx) > Math.abs(dy)) return;

      // Conditions de swipe "volontaire"
      const minDistance = 55;     // px
      const maxTime = 520;        // ms

      if (Math.abs(dy) < minDistance || dt > maxTime) return;

      const currentIndex = getClosestSlideIndex();
      const nextIndex = dy < 0 ? Math.min(currentIndex + 1, slides.length - 1)
                               : Math.max(currentIndex - 1, 0);

      if (nextIndex !== currentIndex) {
        slides[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }, { passive: true });

    function getClosestSlideIndex(){
      const top = slidesEl.scrollTop;
      let best = 0, bestDist = Infinity;

      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetTop - top);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }
  </script>

</body>
</html>
